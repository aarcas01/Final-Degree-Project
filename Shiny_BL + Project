# Updated version of the code used in my undergraduate thesis, combined with a personal project designed to support individual investors in building and optimizing their personal portfolios.

# DISCLAIMER: This Shiny application and all underlying code were developed by Alejandro Arcas. The results generated by the algorithm are for educational and informational purposes only
# and must not be interpreted, under any circumstances, as investment advice or a recommendation to buy or sell any financial asset (as stated in the Shiny code).

# AVISO LEGAL: Esta aplicación Shiny y todo su código interno han sido desarrollados por Alejandro Arcas. Los resultados generados por el algoritmo tienen fines exclusivamente educativos e informativos,
# y en ningún caso deben interpretarse como asesoramiento financiero ni como recomendación de compra o venta de ningún activo financiero (Tal y como se ha especificado en el codigo Shiny).



# This R Shiny app implements the Black-Litterman model to optimize investment portfolios based on both market equilibrium and investor views.
# It downloads stock data from Yahoo Finance, computes expected returns and risk metrics, and visualizes the efficient frontier.
# Users can adjust risk aversion, select assets, and input custom opinions on relative asset performance.
# It compares standard market portfolios with Black-Litterman ones, including simulations with and without rebalancing.
# The app also outputs key financial metrics like Sharpe ratio, IHH, and drawdowns, offering an interactive financial tool.


# Library loading: Uses packages like quadprog, quantmod, shiny, and plotly for financial modeling, visualization, and building the interactive application.
# Asset filtering and classification: Downloads tickers from NASDAQ/NYSE/AMEX and classifies companies by type (stocks, bonds, ETFs, etc.).
# Portfolio optimization: Applies quadratic programming techniques to calculate efficient portfolios, both with and without rebalancing.
# Black-Litterman: Computes adjusted portfolio weights based on investor views, using the matrices P, Q, Ω, and π.
# Visualizations: Includes efficient frontier plots, portfolio composition maps, 3D plots with the Herfindahl-Hirschman Index (IHH), and performance metric comparisons.
# Shiny interface: Provides input forms, asset selectors, risk and knowledge sliders, opinion entry, and execution controls for full user interaction.

# install.packages(c("quadprog", "httr", "rvest", "jsonlite", "ggplot2", "kableExtra", "shiny", "shinyWidgets", "quantmod", "corrplot", "uuid", "sqldf", "plotly", "tidyr", "dplyr", "TTR"))

library(quadprog)
library(httr)
library(rvest)
library(jsonlite)
library(ggplot2)
library(kableExtra)
library(shiny)
library(shinyWidgets)
library(quantmod)
library(corrplot)
library(uuid)
library(httr)
library(rvest)
library(sqldf)
library(plotly)
library(tidyr)
library(dplyr)
library(TTR)


#Download tickers (universe of tickers)

tickers <- stockSymbols(exchange = c("NASDAQ", "NYSE", "AMEX"))
filtro_tickers <- sqldf("SELECT Symbol AS Ticker, Name
                        FROM tickers
                        WHERE Exchange = 'NASDAQ' OR Exchange = 'NYSE' OR Exchange = 'AMEX'
                        ORDER BY Exchange")

palabras <- tolower(filtro_tickers$Name)

palabras <- unlist(strsplit(palabras, "\\s+"))  # Dividir cada nombre en palabras
palabras <- palabras[palabras != ""]  # Eliminar cualquier palabra vacía

frecuencia_palabras <- as.data.frame(table(palabras))
top_palabras <- sqldf("SELECT palabras, Freq
                      FROM frecuencia_palabras
                      ORDER BY Freq desc
                      LIMIT 50")

palabras_clave <- list(
  Common = 1, Shares = 1, Ordinary = 1, Class = 1, Stock = 1, Share = 1, ADR = 1,  ADS = 1,
  ETF = 2, Fund = 2,                                                        
  Warrant = 3, Redeemable = 3,                                              
  Bond = 4, Notes = 4, Perpetual = 4, Interest = 4,  "%" = 4, "Subordinated Debentures" = 4,                       
  Trust = 5, Preferred = 5, Series = 5, Depositary = 5, Cumulative = 5, Beneficial = 5, REIT = 5,
  Unit = 6, 
  Right = 7)

# Clasification of tickers (spanish)

#1: Acciones comunes
#2: Fondos y ETF
#3: Warrants y Opciones
#4: Bonos y notas
#5: Otros
#6: Combinaciones
#7: Derechos de suscripcion

filtro_tickers$Etiquetas <- lapply(1:nrow(filtro_tickers), function(x) list())

for (palabra in names(palabras_clave)) {
  etiqueta <- palabras_clave[[palabra]]
  coincidencias <- grepl(palabra, filtro_tickers$Name, ignore.case = TRUE)
  
  filtro_tickers$Etiquetas[coincidencias] <- Map(function(lista, etq) {
    unique(c(lista, etq))
  }, filtro_tickers$Etiquetas[coincidencias], etiqueta)
}

filtro_tickers$Etiquetas <- sapply(filtro_tickers$Etiquetas, function(x) paste(unlist(x), collapse = ", "))

filtro_tickers$Etiquetas[grepl("Inc\\.|Inc|Ltd|Ltd\\.|Corp|SA", filtro_tickers$Name, ignore.case = TRUE) & filtro_tickers$Etiquetas == ""] <- 1

filtro_tickers$Etiquetas[filtro_tickers$Etiquetas == ""] <- 1

filtro_tickers <- filtro_tickers[!duplicated(filtro_tickers$Name), ]

# Companies database

companies_db <- filtro_tickers

# List of company names
company_choices <- setNames(
  companies_db$Ticker, 
  paste0(companies_db$Name, " (", companies_db$Ticker, ")")
)


# Function optimization portfolio
optimizar_portafolio <- function(retornos, cov_matrix) {
  n <- length(retornos)
  ones <- rep(1, n)
  resultado <- solve.QP(
    Dmat = cov_matrix,
    dvec = rep(0, n),
    Amat = cbind(ones, retornos, diag(n)),
    bvec = c(1, mean(retornos), rep(0, n)),
    meq = 2
  )
  pesos <- resultado$solution
  pesos[pesos < 0.005] <- 0
  pesos <- pesos / sum(pesos)
  return(pesos)
}

# Efficient frontier
# From now, explanation is in spanish. 

frontera_eficiente <- function(retornos, cov_matrix) {
  n <- length(retornos)
  retornos_frontera <- seq(min(retornos) * 1.001, max(retornos) * 0.999, length.out = 250)
  riesgos <- numeric(length(retornos_frontera))
  pesos_frontera <- matrix(NA, nrow = n, ncol = length(retornos_frontera))
  for (i in seq_along(retornos_frontera)) {
    r <- retornos_frontera[i]
    resultado <- tryCatch({
      solve.QP(
        Dmat = cov_matrix,
        dvec = rep(0, n),
        Amat = cbind(rep(1, n), retornos, diag(n)),
        bvec = c(1, r, rep(0, n)),
        meq = 2
      )
    }, error = function(e) {
      return(NULL)
    })
    if (!is.null(resultado) && !any(is.na(resultado$solution))) {
      pesos <- resultado$solution
      pesos[pesos < 0.0001] <- 0
      suma_pesos <- sum(pesos)
      if (suma_pesos > 0) pesos <- pesos / suma_pesos
      riesgo <- sqrt(t(pesos) %*% cov_matrix %*% pesos)
      riesgos[i] <- riesgo
      pesos_frontera[, i] <- pesos
    } else {
      riesgos[i] <- NA
      pesos_frontera[, i] <- rep(NA, n)
    }
  }
  frontera <- data.frame(Retorno = retornos_frontera, Riesgo = riesgos)
  frontera <- frontera[!is.na(frontera$Riesgo), ]
  pesos_frontera <- pesos_frontera[, !is.na(riesgos)]
  return(list(frontera = frontera, pesos = pesos_frontera))
}

analizar_sin_rebalanceo <- function(pesos_optimos, fecha_inicio, fecha_fin, inversion = 1000000) {


  # 1. Extraer Activos de los Nombres de Pesos
  activos <- names(pesos_optimos)
  pesos_iniciales <- as.numeric(pesos_optimos)
  
  # 2. Obtener Datos de los Activos
  getSymbols(activos, from = fecha_inicio, to = fecha_fin, src = "yahoo")
  
  precios <- do.call(merge, lapply(activos, function(x) Ad(get(x))))
  colnames(precios) <- activos
  
  # 3. Calcular Rentabilidades Diarias
  rent_diarias <- (precios - lag(precios, 1)) / lag(precios, 1)
  rent_diarias <- na.omit(rent_diarias)
  fechas <- index(rent_diarias)
  
  # Inicializar variables
  n_activos <- length(pesos_iniciales)
  pesos_actuales <- pesos_iniciales
  pesos_diarios <- matrix(NA, nrow = nrow(rent_diarias), ncol = n_activos)
  colnames(pesos_diarios) <- activos
  rownames(pesos_diarios) <- as.Date(fechas)
  
  inversion_actual <- inversion * pesos_optimos
  
  # Simulación diaria
  for (i in 1:nrow(rent_diarias)) {
    retornos_dia <- as.numeric(rent_diarias[i, ])
    
    # Actualizar valores de la cartera
    inversion_actual <- inversion_actual * (1 + retornos_dia)
    inversion_actual_total <- sum(inversion_actual)
    pesos_actuales <- inversion_actual / inversion_actual_total
    
    # Guardar pesos
    pesos_diarios[i, ] <- pesos_actuales
  }
  
  # Crear DataFrame de resultados
  df_pesos_sin_rebalanceo <- data.frame(Fecha = fechas, pesos_diarios)
  
  # Retorno acumulado
  rendimiento_sin_rebalanceo <- cumprod(1 + rowSums(pesos_diarios * rent_diarias))
  
  # Resultado final
  resultados <- list(
    Pesos_Sin_Rebalanceo = df_pesos_sin_rebalanceo,
    Rendimiento_Sin_Rebalanceo = rendimiento_sin_rebalanceo
  )
  
  return(resultados)
}


analizar_rebalanceo <- function(pesos_optimos, fecha_inicio, fecha_fin, 
                                inversion = 1000000, margen = 0.05, 
                                trading_cost = 0) {
  if (length(pesos_optimos) == 0) stop("pesos_optimos no puede estar vacío")
  if (margen < 0 || margen > 1) stop("Margen debe estar entre 0 y 1")
  if (trading_cost < 0 || trading_cost > 1) stop("trading_cost debe estar entre 0 y 1")
  
  # 1. Extraer Activos de los Nombres de Pesos
  activos <- names(pesos_optimos)
  pesos_iniciales <- as.numeric(pesos_optimos)
  
  # 2. Obtener Datos de los Activos
  getSymbols(activos, from = fecha_inicio, to = fecha_fin, src = "yahoo")
  precios <- do.call(merge, lapply(activos, function(x) Ad(get(x))))
  colnames(precios) <- activos
  
  # 3. Calcular Rentabilidades Diarias
  rent_diarias <- na.omit((precios - lag(precios, 1)) / lag(precios, 1))
  fechas <- index(rent_diarias)
  
  # Inicializar variables
  n_activos <- length(pesos_iniciales)
  pesos_actuales <- pesos_iniciales
  pesos_diarios_rebalanceo <- matrix(NA, nrow = nrow(rent_diarias), ncol = n_activos)
  colnames(pesos_diarios_rebalanceo) <- activos
  rownames(pesos_diarios_rebalanceo) <- as.Date(fechas)
  contador_rebalanceo <- 0
  
  inversion_actual <- inversion * pesos_optimos
  inversion_total_bruta <- inversion
  inversion_total_neta <- inversion
  rentabilidades_brutas <- numeric(nrow(rent_diarias))
  rentabilidades_netas <- numeric(nrow(rent_diarias))
  
  # Simulación diaria
  for (i in 1:nrow(rent_diarias)) {
    retornos_dia <- as.numeric(rent_diarias[i, ])
    
    # Actualizar valores para cartera con rebalanceo
    inversion_actual <- inversion_actual * (1 + retornos_dia)
    inversion_total_bruta <- sum(inversion_actual)
    pesos_actuales <- inversion_actual / inversion_total_bruta
    
    # Guardar rentabilidad diaria bruta
    rentabilidad_bruta_dia <- sum(pesos_actuales * retornos_dia)
    rentabilidades_brutas[i] <- rentabilidad_bruta_dia
    
    # Rebalanceo
    margen_sup <- pesos_iniciales + margen
    margen_inf <- pesos_iniciales - margen
    
    if (any(pesos_actuales > margen_sup | pesos_actuales < margen_inf)) {
      contador_rebalanceo <- contador_rebalanceo + 1
      
      # Calcular coste de trading basado en la parte rebalanceada
      if (trading_cost > 0) {
        diferencias <- abs(pesos_actuales - pesos_iniciales)  # Diferencias de pesos
        costo_rebalanceo <- sum(diferencias * inversion_total_neta * trading_cost)
        inversion_total_neta <- max(0, inversion_total_neta - costo_rebalanceo)  # No permitir valores negativos
      }
      
      # Rebalancear
      inversion_actual <- inversion_total_neta * pesos_iniciales
      pesos_actuales <- pesos_iniciales
    }
    
    # Guardar rentabilidad diaria neta
    rentabilidad_neta_dia <- sum(pesos_actuales * retornos_dia)
    rentabilidades_netas[i] <- rentabilidad_neta_dia
    
    # Actualizar pesos diarios con rebalanceo
    pesos_diarios_rebalanceo[i, ] <- pesos_actuales
  }
  
  # Rentabilidad acumulada
  rendimiento_bruto <- cumprod(1 + rentabilidades_brutas) - 1
  rendimiento_neto <- cumprod(1 + rentabilidades_netas) - 1
  
  # Crear DataFrame de resultados
  df_pesos_rebalanceo <- data.frame(Fecha = fechas, pesos_diarios_rebalanceo)
  
  # Resultado final
  resultados <- list(
    Pesos_Rebalanceo = df_pesos_rebalanceo,
    Contador_Rebalanceo = contador_rebalanceo,
    Rentabilidad_Bruta = rendimiento_bruto,
    Rentabilidad_Neta = rendimiento_neto
  )
  
  return(resultados)
}

# Interfaz de usuario
# Interfaz de usuario actualizada
ui <- fluidPage(
  titlePanel(
    tags$h2("Optimización de Portafolios de Black-Litterman", style = "text-align: center; color: #2c3e50; font-weight: bold;")
  ),
  sidebarLayout(
    sidebarPanel(
      sliderInput("financial_knowledge", "Nivel de Conocimiento Financiero (0-10):", 
                  min = 0, max = 10, value = 5, width = '100%'),
      tags$small("0: Sin conocimientos financieros"), br(),
      tags$small("10: Experto con profundo conocimiento"), br(), br(),
      sliderInput("risk_aversion", "Aversión al Riesgo (0-10):", min = 0, max = 10, value = 5, width = '100%'),
      tags$small("0: Muy tolerante al riesgo"), br(),
      tags$small("10: Muy averso al riesgo"), br(), br(),
      selectInput("cov_matrix_type", "Seleccionar tipo de Matriz de Covarianzas:",
                  choices = list("Estandar" = "estandar", "Gerber" = "gerber"), selected = "estandar"),
      textInput("c_value", "Valor de c:", value = "0.5", placeholder = "Ejemplo: 0.5"),
      tags$small("Ingrese un valor entre 0.01 y 0.99", style = "color: #7f8c8d;"), br(), br(),
      selectizeInput("available_companies", "Seleccione un activo:", 
                     choices = c("Seleccione un activo" = "", company_choices),
                     options = list(maxOptions = 1000)),
      tags$small("Es posible que ciertos activos no puedan ser importado debido a las limitaciones de
                 Yahoo Finance y la funcion getSymbols().", style = "color: #7f8c8d;"),
      br(),
      fluidRow(
        column(6, actionButton("add_company", "Agregar activo", class = "btn btn-success")),
        column(6, actionButton("reset_selection", "Resetear selección", class = "btn btn-danger"))
      ),
      br(), br(),
      h3("Activos seleccionados:"),
      uiOutput("selected_companies_output")
    ),
    mainPanel(
      h3("Aviso", style = "color: #2c3e50; margin-top: 20px; font-weight: bold;"),
      p("Este programa Shiny, incluyendo su código interno, ha sido desarrollado por Alejandro Arcas. 
    En ningún caso se deben interpretar los resultados como recomendación de compra o venta.", 
    style = "color: grey; font-size: 12px; font-style: italic; text-align: justify;"),
      hr(),
      h4("Opiniones del inversor", style = "color: #2c3e50; margin-top: 20px; text-align: center"),
      fluidRow(
        column(6, textInput("start_date", "Fecha Inicio de Estudio (YYYY-MM-DD):", placeholder = "2021-01-01")),
        column(6, textInput("end_date", "Fecha Fin de Estudio (YYYY-MM-DD):", placeholder = "2024-01-01"))
      ),
      br(),
      fluidRow(
        column(6, textInput("evaluation_start_date", "Fecha Inicio de Evaluación (YYYY-MM-DD):", placeholder = "2024-01-02")),
        column(6, textInput("evaluation_end_date", "Fecha Fin de Evaluación (YYYY-MM-DD):", placeholder = "2024-12-31"))
      ),
      br(),
      h4("Opiniones", style = "color: #2c3e50; margin-top: 20px; text-align: center"),
      actionButton("add_opinion", "Añadir opinión", class = "btn btn-primary", style = "margin-top: 10px;"),
      br(), br(),
      uiOutput("opinions_ui"),
      actionButton("run_analysis", "Ejecutar", class = "btn btn-warning", style = "margin-top: 20px;"),
      hr(), br(),
      h3("Resultados", style = "color: #2c3e50; 20px; font-weight: bold; text-align: center"),
      # Gráfico de la frontera eficiente
      
      h4("Evolución de Rentabilidades", style = "color: #2c3e50; margin-top: 20px;"),
      plotOutput("grafico_evolucion_rentabilidad", height = "600px"),
    
      h4("Gráfico de covarianzas"),
      plotOutput("grafico_covarianza", height = "400px"),
      br(),
      h4("Gráfico de Frontera Eficiente"),
      plotOutput("grafico_frontera", height = "600px"),
      br(),
      h4("Pesos Calculados para las Carteras", style = "color: #2c3e50; margin-top: 20px;"),
    
      h4("Distribución del Índice de Herfindahl-Hirschman (IHH)", style = "color: #2c3e50; margin-top: 40px;"),
      plotOutput("grafico_violinplot", height = "600px"),
      plotlyOutput("grafico_3d"),
    
      
      # Tabla de Pesos Mínimo Riesgo Mercado
      uiOutput("tabla_minrisk_mercado"),
      
      # Tabla de Pesos Sharpe Máximo Mercado
      uiOutput("tabla_optimos_mercado"),
      
      # Tabla de Pesos Mínimo Riesgo Black-Litterman
      uiOutput("tabla_minrisk_bl"),
      
      # Tabla de Pesos Sharpe Máximo Black-Litterman
      uiOutput("tabla_optimos_bl"),
      
      uiOutput("tabla_pesos_combinada"),
      
      h4("Distribución de Pesos: Mercado"),
      plotOutput("composition_map_mercado", height = "400px"),
      
      h4("Distribución de Pesos: Black-Litterman"),
      plotOutput("composition_map_bl", height = "400px"),
    
      h3("Gráfico de Rentabilidades Netas", style = "color: #2c3e50; margin-top: 20px;"),
      plotOutput("grafico_rentabilidades", height = "400px"),
      
      h3("Tabla Comparativa de Métricas", style = "color: #2c3e50; margin-top: 40px;"),
      uiOutput("tabla_comparativa"),
      br(), br(),
      
      # Resultados Intermedios
      h3("Resultados Intermedios"),
    
      h4("Rentabilidades Diarias (Primeras Filas):"),
      verbatimTextOutput("rent_diarios_head"),
      
      h4("Matriz P:"),
      verbatimTextOutput("P_matrix"),
      
      h4("Vector Q:"),
      verbatimTextOutput("Q_vector"),
      
      h4("Vector pi_normalizado:"),
      verbatimTextOutput("pi_normalizado_vector"),
      
      h4("Matriz Omega:"),
      verbatimTextOutput("omega_matrix"),
    )
  )
)



# Lógica del servidor
server <- function(input, output, session) {
  # Variables reactivas
  selected_companies <- reactiveVal(character(0))
  opinions_list <- reactiveValues(data = list())
  
  # Añadir activos seleccionados
  observeEvent(input$add_company, {
    if (input$available_companies != "") {
      current_companies <- selected_companies()
      if (!input$available_companies %in% current_companies) {
        current_companies <- c(current_companies, input$available_companies)
        selected_companies(current_companies)
      }
    }
  })
  
  # Quitar activos seleccionados
  observeEvent(input$remove_company, {
    company_to_remove <- input$remove_company
    current_companies <- setdiff(selected_companies(), company_to_remove)
    selected_companies(current_companies)
    
    # Actualizar opiniones si el activo eliminado está en ellas
    opinions_list$data <- lapply(opinions_list$data, function(opinion) {
      if (opinion$left == company_to_remove || opinion$right == company_to_remove) {
        NULL  # Eliminar la opinión que contiene el activo eliminado
      } else {
        opinion  # Mantener las opiniones válidas
      }
    })
    opinions_list$data <- opinions_list$data[!sapply(opinions_list$data, is.null)]
  })
  
  # Mostrar activos seleccionados
  output$selected_companies_output <- renderUI({
    if (length(selected_companies()) > 0) {
      tagList(
        lapply(selected_companies(), function(company) {
          div(
            style = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border: 1px solid #ddd; padding: 5px; border-radius: 5px;",
            span(company, style = "font-weight: bold;"),
            actionButton(
              inputId = paste0("remove_", company),
              label = "Quitar",
              class = "btn btn-danger btn-sm",
              onclick = sprintf("Shiny.setInputValue('remove_company', '%s')", company)
            )
          )
        })
      )
    } else {
      tags$p("No se han seleccionado activos.", style = "text-align: center; color: #7f8c8d;")
    }
  })
  
  # Renderizar opiniones
  output$opinions_ui <- renderUI({
    if (length(selected_companies()) > 0) {
      tagList(
        lapply(names(opinions_list$data), function(id) {
          opinion <- opinions_list$data[[id]]
          fluidRow(
            column(3, selectizeInput(
              inputId = paste0("opinion_left_", id),
              label = "Activo (Mejor)",
              choices = selected_companies(),
              selected = opinion$left
            )),
            column(3, selectizeInput(
              inputId = paste0("opinion_right_", id),
              label = "Activo (Peor)",
              choices = selected_companies(),
              selected = opinion$right
            )),
            column(3, numericInput(
              inputId = paste0("opinion_value_", id),
              label = "Exceso de Rentabilidad (%)",
              value = opinion$value
            )),
            column(2, actionButton(
              inputId = paste0("remove_opinion_", id),
              label = "Eliminar opinión",
              class = "btn btn-danger btn-sm",
              style = "margin-top: 25px;"
            ))
          )
        })
      )
    }
  })
  
  # Sincronizar inputs dinámicos con opinions_list$data
  observe({
    lapply(names(opinions_list$data), function(id) {
      observeEvent(input[[paste0("opinion_left_", id)]], {
        opinions_list$data[[id]]$left <- input[[paste0("opinion_left_", id)]]
      }, ignoreInit = TRUE)
      
      observeEvent(input[[paste0("opinion_right_", id)]], {
        opinions_list$data[[id]]$right <- input[[paste0("opinion_right_", id)]]
      }, ignoreInit = TRUE)
      
      observeEvent(input[[paste0("opinion_value_", id)]], {
        opinions_list$data[[id]]$value <- input[[paste0("opinion_value_", id)]]
      }, ignoreInit = TRUE)
    })
  })
  
  # Añadir nueva opinión
  observeEvent(input$add_opinion, {
    new_id <- UUIDgenerate()
    opinions_list$data[[new_id]] <- list(left = "", right = "", value = 0)
  })
  
  observeEvent(input$run_analysis, {
    # Validación de fechas
    # Validar entradas de fecha
    if (is.null(input$start_date) || is.null(input$end_date) ||
        is.null(input$evaluation_start_date) || is.null(input$evaluation_end_date) ||
        input$start_date == "" || input$end_date == "" ||
        input$evaluation_start_date == "" || input$evaluation_end_date == "") {
      showModal(modalDialog(
        title = "Error en las fechas",
        "Por favor, complete todas las fechas antes de continuar.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Intentar convertir a fechas
    start_date <- tryCatch(as.Date(input$start_date), error = function(e) NULL)
    end_date <- tryCatch(as.Date(input$end_date), error = function(e) NULL)
    evaluation_start_date <- tryCatch(as.Date(input$evaluation_start_date), error = function(e) NULL)
    evaluation_end_date <- tryCatch(as.Date(input$evaluation_end_date), error = function(e) NULL)
    
    if (is.null(start_date) || is.null(end_date) ||
        is.null(evaluation_start_date) || is.null(evaluation_end_date)) {
      showModal(modalDialog(
        title = "Error en las fechas",
        "Formato de fecha no válido. Use el formato 'YYYY-MM-DD'.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Validación lógica de las fechas
    if (end_date >= evaluation_start_date) {
      showModal(modalDialog(
        title = "Error en las fechas",
        "La Fecha de Fin de Estudio debe ser menor a la Fecha de Inicio de Evaluación.",
        easyClose = TRUE
      ))
      return()
    }
    if (evaluation_end_date > Sys.Date() - 7) {
      showModal(modalDialog(
        title = "Error en las fechas",
        "La Fecha de Fin de Evaluación no puede ser más reciente que hace 7 días.",
        easyClose = TRUE
      ))
      return()
    }
  })
  
  # Eliminar opinión
  observe({
    lapply(names(opinions_list$data), function(id) {
      observeEvent(input[[paste0("remove_opinion_", id)]], {
        opinions_list$data[[id]] <- NULL
      })
    })
  })
  
  
  observeEvent(input$run_analysis, {
    # Validar entradas
    if (length(selected_companies()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "No se han seleccionado activos. Por favor, seleccione al menos un activo antes de ejecutar.",
        easyClose = TRUE
      ))
      return()
    }
    
    if (is.na(as.numeric(input$c_value)) || as.numeric(input$c_value) < 0.01 || as.numeric(input$c_value) > 0.99) {
      showModal(modalDialog(
        title = "Error",
        "Ingrese un valor válido de c entre 0.01 y 0.99.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Descargar precios de los activos seleccionados
    selected_assets <- selected_companies()
    start_date <- input$start_date
    end_date <- input$end_date
    
    message("Iniciando descarga de precios para los activos seleccionados...")
    tickers_validos <- c()
    datos_acciones <- list()
    
    for (ticker in selected_assets) {
      tryCatch({
        datos <- getSymbols(ticker, src = "yahoo", from = start_date, to = end_date, auto.assign = FALSE)
        cierre_ajustado <- Cl(datos)
        if (any(!is.na(cierre_ajustado))) {
          tickers_validos <- c(tickers_validos, ticker)
          datos_acciones[[ticker]] <- cierre_ajustado
        }
      }, error = function(e) {
        message("Error al descargar datos para el activo: ", ticker)
      })
    }
    
    if (length(datos_acciones) > 1) {
      datos_precios <- Reduce(function(x, y) merge(x, y, all = TRUE), datos_acciones)
      datos_precios <- na.omit(datos_precios)
    } else if (length(datos_acciones) == 1) {
      datos_precios <- datos_acciones[[1]]
    } else {
      showModal(modalDialog(
        title = "Error",
        "No se pudieron obtener datos válidos para los activos seleccionados.",
        easyClose = TRUE
      ))
      return()
    }
    colnames(datos_precios) <- tickers_validos
    
    message("Descarga de precios completada para los activos seleccionados: ", paste(tickers_validos, collapse = ", "))
    
    # Calcular rentabilidades diarias
    rent_diarios <- diff(log(datos_precios))
    rent_diarios <- na.omit(rent_diarios)
    output$rent_diarios_res <- renderPrint({ head(rent_diarios) })
    
    if (is.null(rent_diarios) || ncol(rent_diarios) < 2 || nrow(rent_diarios) < 2) {
      showModal(modalDialog(
        title = "Error",
        "Rentabilidades diarias insuficientes para calcular la matriz de covarianza.",
        easyClose = TRUE
      ))
      return()
    }
    
    message("Cálculo de rentabilidades diarias completado.")
    
    output$rent_diarios_head <- renderPrint({head(rent_diarios)})
    
    
    # Descargar datos de referencia para Rf y benchmark
    tryCatch({
      message("Descargando datos de referencia para Rf (TNX) y benchmark (GSPC)...")
      getSymbols("^TNX", src = "yahoo", from = start_date, to = end_date)
      TNX_datos <- na.omit(TNX[, 4])
      Rf_anual <- as.numeric(TNX_datos[nrow(TNX_datos)]) / 100
      Rf_mensual <- (1 + Rf_anual)^(1 / 12) - 1
      Rf <- (1 + Rf_anual)^(1 / 256) - 1
      
      getSymbols("^GSPC", from = start_date, to = end_date)
      price_SP <- GSPC[, 4]
      rent_diaria_SP <- na.omit(diff(log(price_SP)))
      rent_mensuales_SP <- apply.monthly(rent_diaria_SP, colSums)
      rent_mensuales_SP <- exp(rent_mensuales_SP) - 1
      rent_mensuales_SP <- na.omit(rent_mensuales_SP)
      benchmark <- as.numeric(colMeans(rent_mensuales_SP))
    }, error = function(e) {
      message("Error al descargar datos de referencia: ", e$message)
      showModal(modalDialog(
        title = "Error",
        "No se pudieron descargar datos de referencia (Rf o benchmark).",
        easyClose = TRUE
      ))
      return()
    })
    
    
    message("Datos de referencia descargados")
    
    
    
    message("Calculo lambda")
    
    lambda <- (benchmark - Rf_mensual) / sd(na.omit(rent_mensuales_SP))^2
    
    message("Creando grafico evolucion activos seleccionados")
    
    retornos_normalizados <- apply(datos_precios, 2, function(columna) columna / columna[1])
    i_precio_SP <- price_SP[, 1] / as.numeric(price_SP[1, 1])
    i_numeric_SP <- as.numeric(coredata(i_precio_SP))
    drawdowns_SP <- (i_numeric_SP / cummax(i_numeric_SP) - 1) * 100
    
    output$grafico_evolucion_rentabilidad <- renderPlot({
      # Convertir los datos a formato largo
      retornos_normalizados_dataframe <- as.data.frame(retornos_normalizados)
      retornos_normalizados_dataframe$Date <- as.Date(row.names(retornos_normalizados))
      
      retornos_long <- retornos_normalizados_dataframe %>%
        pivot_longer(cols = -Date, names_to = "Activo", values_to = "Rentabilidad")
      
      # Crear un data frame para i_numeric_SP con las fechas correspondientes
      i_numeric_SP_df <- data.frame(
        Date = retornos_normalizados_dataframe$Date,
        Rentabilidad = i_numeric_SP,
        Activo = "SP500"
      )
      
      # Combinar retornos_long y i_numeric_SP_df
      retornos_long <- bind_rows(retornos_long, i_numeric_SP_df)
      
      # Crear el gráfico
      ggplot(retornos_long, aes(x = Date, y = Rentabilidad, color = Activo)) +
        geom_line(data = subset(retornos_long, Activo != "SP500"), linewidth = 0.5) +
        geom_line(data = subset(retornos_long, Activo == "SP500"), color = "black", linewidth = 1, aes(linetype = Activo)) +
        geom_hline(yintercept = 1, linetype = "dashed", color = "black") +
        labs(title = "Evolución de la rentabilidad de las acciones del portafolio", x = NULL, y = "Rentabilidad") +
        scale_linetype_manual(values = c("SP500" = "solid")) +
        theme_minimal() +
        theme(
          legend.position = "bottom",
          legend.title = element_blank()
        )
    })
    
    # Función para descargar Market Caps
    get_market_cap = function(tag){
      url <- paste0("https://www.macrotrends.net/assets/php/market_cap.php?t=", tag)
      user_agent <- "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 
          (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Edg/94.0.992.50"
      
      response <- GET(url, user_agent(user_agent))
      content = content(response, "text")
      
      data_text = content %>% 
        read_html() %>% 
        html_nodes(xpath  ="/html/body/script") %>% 
        html_text() 
      
      part_json <- regmatches(data_text, regexpr("\\[.*?\\]", data_text))[1]
      
      marketcap = fromJSON(part_json)
      names(marketcap) = c("Date", "MarketCap")
      
      marketcap$Date = as.Date(marketcap$Date)
      marketcap_def = marketcap[which(marketcap$Date>=as.Date(end_date)-11),]
      marketcap_def = marketcap_def[which(marketcap_def$Date<=as.Date(end_date)-7),]
      
      return(marketcap_def$MarketCap)
    }
    
    # Descargar market caps
    message("Descargando datos de capitalización de mercado...")
    mat_marketcap <- matrix(nrow = 50, ncol = length(tickers_validos))
    for (i in 1:length(tickers_validos)) {
      vect <- get_market_cap(tickers_validos[i])
      message("Descargado market cap para: ", names(datos_precios)[i])
      length(vect) <- 50
      mat_marketcap[, i] <- vect
      Sys.sleep(10)
    }
    market_cap <- data.frame(mat_marketcap)
    colnames(market_cap) <- tickers_validos
    market_cap <- market_cap[, colSums(is.na(market_cap)) < nrow(market_cap)]
    market_cap <- market_cap[rowSums(is.na(market_cap)) < ncol(market_cap), ]
    market_cap_final <- market_cap[nrow(market_cap), ]
    market_cap_final <- market_cap_final / sum(market_cap_final)
    market_cap_final <- as.matrix(t(market_cap_final))
    message("Datos de market cap descargados correctamente.", paste(colnames(market_cap_final), collapse = ", "))
    
    # Matriz de covarianza
    message("Calculando matriz de covarianza...")
    cov_matrix <- switch(input$cov_matrix_type,
                         "estandar" = cov(rent_diarios),
                         "gerber" = {
                           n_assets <- ncol(rent_diarios)
                           std_devs <- apply(rent_diarios, 2, sd, na.rm = TRUE)
                           thresholds <- as.numeric(input$c_value) * std_devs
                           gerber_matrix <- matrix(0, nrow = n_assets, ncol = n_assets,
                                                   dimnames = list(colnames(rent_diarios), colnames(rent_diarios)))
                           for (i in 1:(n_assets - 1)) {
                             for (j in (i + 1):n_assets) {
                               rent_i <- rent_diarios[, i]
                               rent_j <- rent_diarios[, j]
                               movements <- ((rent_i >= thresholds[i] & rent_j >= thresholds[j]) |
                                               (rent_i <= -thresholds[i] & rent_j <= -thresholds[j])) -
                                 ((rent_i >= thresholds[i] & rent_j <= -thresholds[j]) |
                                    (rent_i <= -thresholds[i] & rent_j >= thresholds[j]))
                               movements <- movements[!is.na(movements)]
                               if (length(movements) > 0) {
                                 gerber_matrix[i, j] <- sum(movements) / length(movements)
                                 gerber_matrix[j, i] <- gerber_matrix[i, j]
                               }
                             }
                           }
                           diag(gerber_matrix) <- 1
                           diag(std_devs) %*% gerber_matrix %*% diag(std_devs)
                         })
    
    titulo <- if (input$cov_matrix_type == "gerber") {
      paste("Correlación entre activos con el Estadístico de Gerber (c =", input$c_value, ")")
    } else {
      "Correlación entre activos con la Matriz de Covarianza: Estandar"
    }
    
    message("matriz de covarianza ", paste(cov_matrix, sep = "", collapse = "\n"))
    
    # Gráfico de la matriz de covarianza
    output$grafico_covarianza <- renderPlot({
      corrplot(cov2cor(cov_matrix), method = "color", type = "upper", 
               tl.col = "black", tl.srt = 30, addCoef.col = "black", 
               title = titulo, 
               mar = c(0, 0, 1, 0))
    })
    
    message("Matriz de covarianza calculada.")
    
    # Debug: Imprimir las opiniones cargadas
    message("Opinions loaded: ", paste(capture.output(print(opinions_list$data)), collapse = "\n"))
    
    # Debug: Comprobar los activos seleccionados
    message("Selected companies: ", paste(selected_companies(), collapse = ", "))
    
    # Debug: Verificar coincidencia entre activos seleccionados y columnas de la matriz de covarianza
    message("Covariance matrix columns: ", paste(colnames(cov_matrix), collapse = ", "))
    
    # Crear matrices P y Q
    message("Creando matrices P y Q para Black-Litterman...")
    message("Opinions loaded: ", paste(capture.output(print(opinions_list$data)), collapse = "\n"))
    
    if (length(opinions_list$data) > 0) {
      # Initialize P matrix with zeros
      P <- matrix(0, nrow = length(opinions_list$data), ncol = ncol(cov_matrix))
      colnames(P) <- colnames(cov_matrix)
      Q <- (numeric(length(opinions_list$data)))
      
      
      # Iterate over opinions to populate P and Q
      for (i in seq_along(opinions_list$data)) {
        opinion <- opinions_list$data[[i]]
        
        if (!is.null(opinion$left) && !is.null(opinion$right) &&
            opinion$left %in% colnames(P) && opinion$right %in% colnames(P)) {
          P[i, opinion$left] <- 1
          P[i, opinion$right] <- -1
          Q[i] <- ((opinion$value / 100) + 1)^(1/256) - 1
        } else {
          message(sprintf(
            "Invalid opinion: left='%s', right='%s'. Skipping.", 
            opinion$left %||% "NULL", opinion$right %||% "NULL"
          ))
        }
      }
      
      # Check if P and Q are correctly populated
      if (all(P == 0) || all(Q == 0)) {
        showModal(modalDialog(
          title = "Error",
          "The matrices P and Q could not be generated correctly. Please verify the investor's opinions.",
          easyClose = TRUE
        ))
        return()
      }
      
      output$P_matrix <- renderPrint({ P })
      output$Q_vector <- renderPrint({ Q })
    } else {
      showModal(modalDialog(
        title = "Error",
        "No investor opinions available to compute Black-Litterman.",
        easyClose = TRUE
      ))
      return()
    }
    
    
    
    
    output$matrix_p <- renderPrint({ opinions_list })
    output$matrix_p_data <- renderPrint({ opinions_list$data })
    output$matrix_p <- renderPrint({ P })
    output$matrix_q <- renderPrint({ Q })
    message("Matrices P y Q creadas.")
    
    message("Dimensiones de P: ", paste(dim(P), collapse = " x "))
    message("Contenido de P: \n", paste(capture.output(print(P)), collapse = "\n"))
    
    message("Dimensiones de Q: ", length(Q))
    message("Contenido de Q: \n", paste(capture.output(print(Q)), collapse = "\n"))
    
    # Calcular Black-Litterman
    message("Calculando retornos ajustados Black-Litterman...")
    tau <- 0.005 + (as.numeric(input$financial_knowledge) / 10) * (0.05 - 0.005)
    
    if (length(Q) == 1) {
      omega <- (P %*% cov_matrix %*% t(P)) * tau
    } else {
      omega <- diag(diag(P %*% cov_matrix %*% t(P))) * tau
    }
    
    message("Dimensiones de omega: ", paste(dim(omega), collapse = " x "))
    message("Contenido de omega: \n", paste(capture.output(print(omega)), collapse = "\n"))
    
    pi_normalizado <- lambda * (cov_matrix %*% market_cap_final) + Rf
    
    message("Dimensiones de pi_normalizado: ", length(pi_normalizado))
    message("Contenido de pi_normalizado: \n", paste(capture.output(print(pi_normalizado)), collapse = "\n"))
  
    output$P_matrix <- renderPrint({ P })
    output$Q_vector <- renderPrint({ Q })
    output$omega_matrix <- renderPrint({ omega })
    output$pi_normalizado_vector <- renderPrint({ pi_normalizado })
    
    if (length(Q) != nrow(P)) stop("Error: Q y P no coinciden en dimensiones.")
    if (det(tau * cov_matrix) == 0) stop("Error: tau * cov_matrix es singular.")
    
    retornos_bl <- solve(solve(tau * cov_matrix) + t(P) %*% solve(omega) %*% P) %*%
      (solve(tau * cov_matrix) %*% pi_normalizado + t(P) %*% solve(omega) %*% Q)
    cov_matrix_bl <- cov_matrix + solve(solve(tau * cov_matrix) + t(P) %*% solve(omega) %*% P)
    message("Retornos ajustados calculados.")
    
    output$pi_normalizado_vector <- renderPrint({ retornos_bl })
    output$pi_normalizado_vector <- renderPrint({ cov_matrix_bl })
    
    # Fronteras eficientes y gráficos
    message("Calculando fronteras eficientes...")
    resultado_mercado <- frontera_eficiente(pi_normalizado, cov_matrix)
    resultado_bl <- frontera_eficiente(retornos_bl, cov_matrix_bl)
    
    # Extraer los datos individuales
    frontera_mercado <- resultado_mercado$frontera
    pesos_mercado <- resultado_mercado$pesos
    
    frontera_bl <- resultado_bl$frontera
    pesos_bl <- resultado_bl$pesos
    
    # Filtrar solo retornos superiores al mínimo riesgo
    frontera_mercado_filtrado <- frontera_mercado[frontera_mercado$Retorno > frontera_mercado$Retorno[which.min(frontera_mercado$Riesgo)], ]
    frontera_bl_filtrado <- frontera_bl[frontera_bl$Retorno > frontera_bl$Retorno[which.min(frontera_bl$Riesgo)], ]
    message("Fronteras Eficientes calculadas")
    # -------------------------------------------------
    # 📊 7. Gráficos
    # -------------------------------------------------
    message("Data frames")
    activos_mercado <- data.frame(Retorno = as.numeric(pi_normalizado),
                                  Riesgo = sqrt(diag(cov_matrix)))
    
    activos_bl <- data.frame(Retorno = as.numeric(retornos_bl),
                             Riesgo = sqrt(diag(cov_matrix_bl)))
    
    message("Sharpe Ratios y gráficos")
    # Calcular Sharpe Ratios para Mercado
    sharpe_ratios_mercado <- (frontera_mercado$Retorno - Rf) / frontera_mercado$Riesgo
    indice_sharpe_mercado <- which.max(sharpe_ratios_mercado)
    riesgo_sharpe_mercado <- frontera_mercado$Riesgo[indice_sharpe_mercado]
    retorno_sharpe_mercado <- frontera_mercado$Retorno[indice_sharpe_mercado]  # Retorno correspondiente
    
    # Calcular Sharpe Ratios para Black-Litterman
    sharpe_ratios_bl <- (frontera_bl$Retorno - Rf) / frontera_bl$Riesgo
    indice_sharpe_bl <- which.max(sharpe_ratios_bl)
    riesgo_sharpe_bl <- frontera_bl$Riesgo[indice_sharpe_bl]
    retorno_sharpe_bl <- frontera_bl$Retorno[indice_sharpe_bl]  # Retorno correspondiente
    
    #Minimo riesgo
    retorno_min_riesgo_mercado <- resultado_mercado$frontera$Retorno[which.min(resultado_mercado$frontera$Riesgo)]
    riesgo_min_mercado <- min(resultado_mercado$frontera$Riesgo)
    
    retorno_min_riesgo_bl <- resultado_bl$frontera$Retorno[which.min(resultado_bl$frontera$Riesgo)]
    riesgo_min_bl <- min(resultado_bl$frontera$Riesgo)
    
    message("Pesos óptmios")
    #Pesos optimos
    pesos_optimos_mercado <- pesos_mercado[,indice_sharpe_mercado]
    pesos_optimos_bl <- pesos_bl[,indice_sharpe_bl]
    
    message("Pesos de la cartera de mercado", paste(capture.output(print(pesos_optimos_mercado)), collapse = "\n"))
    message("Pesos de la cartera de BL", paste(capture.output(print(pesos_optimos_bl)), collapse = "\n"))
    
    df_pesos <- data.frame(
      Activo = colnames(market_cap_final),
      Peso_Inicial = market_cap_final,
      Peso_Optimo_Mercado = pesos_optimos_mercado,
      Peso_Optimo_BL = pesos_optimos_bl
    )
    
    output$pi_normalizado_vector <- renderPrint({ df_pesos })
    
    message("Df pesos", paste(capture.output(print(df_pesos)), collapse = "\n"))
    
    # Crear un DataFrame consolidado para activos
    activos_mercado$Modelo <- "Mercado"
    activos_bl$Modelo <- "Black-Litterman"
    activos_totales <- rbind(activos_mercado, activos_bl)
    
    message("Grafico")
    output$grafico_frontera <- renderPlot({
      ggplot() +
        # Puntos de la Frontera Eficiente
        geom_point(data = frontera_mercado, aes(x = Riesgo, y = Retorno, color = "Mercado"), size = 1, alpha = 0.5) +
        geom_point(data = frontera_bl, aes(x = Riesgo, y = Retorno, color = "Black-Litterman"), size = 1, alpha = 0.5) +
        
        # Puntos de los Activos
        geom_point(data = activos_mercado, aes(x = Riesgo, y = Retorno, color = "Mercado"), size = 3) +
        geom_point(data = activos_bl, aes(x = Riesgo, y = Retorno, color = "Black-Litterman"), size = 3) +
        
        # Nombres de los Activos
        geom_text(data = activos_mercado, aes(x = Riesgo, y = Retorno, label = rownames(activos_mercado)), 
                  vjust = -1, hjust = 1, size = 3, color = "black") +
        geom_text(data = activos_bl, aes(x = Riesgo, y = Retorno, label = rownames(activos_bl)), 
                  vjust = -1, hjust = 1, size = 3, color = "black") +
        
        # Punto Sharpe Óptimo (Mercado)
        geom_point(aes(x = riesgo_sharpe_mercado, y = retorno_sharpe_mercado, color = "Sharpe Óptimo (Mercado)"), size = 4, shape = 18) +
        
        # Punto Sharpe Óptimo (Black-Litterman)
        geom_point(aes(x = riesgo_sharpe_bl, y = retorno_sharpe_bl, color = "Sharpe Óptimo (BL)"), size = 4, shape = 18) +
        
        # Punto de Riesgo Mínimo (Mercado)
        geom_point(aes(x = riesgo_min_mercado, y = retorno_min_riesgo_mercado, color = "Min (Mercado)"), size = 4, shape = 1) +
        
        # Punto de Riesgo Mínimo (Black-Litterman)
        geom_point(aes(x = riesgo_min_bl, y = retorno_min_riesgo_bl, color = "Min (BL)"), size = 4, shape = 1) +
        
        # Etiquetas y Tema
        labs(title = "Frontera Eficiente con Puntos Óptimos y Mínimos de Riesgo", 
             x = "Riesgo", y = "Retorno", color = "Modelo") +
        
        scale_color_manual(values = c(
          "Mercado" = "blue",
          "Black-Litterman" = "red",
          "Sharpe Óptimo (Mercado)" = "blue",
          "Sharpe Óptimo (BL)" = "red",
          "Min (Mercado)" = "blue",
          "Min (BL)" = "red"
        )) +
        
        theme_minimal() +
        theme(legend.position = "bottom", legend.title = element_text(face = "bold"))
    })
    message("Fronteras eficientes calculadas y gráfico generado.")
    
    composicion_mercado <- data.frame(Retorno = resultado_mercado$frontera$Retorno,
                                      t(resultado_mercado$pesos))
    
    composicion_mercado_larga <- pivot_longer(composicion_mercado,
                                              cols = -Retorno, names_to = "Activo", values_to = "Peso")


  # Gráfico corregido
    output$composition_map_mercado <- renderPlot({
      ggplot(composicion_mercado_larga, aes(x = Retorno, y = Peso, fill = Activo)) +
        geom_area(position = "stack") +
        geom_vline(xintercept = retorno_sharpe_mercado, color = "black", linetype = "solid", size = 1) +
        annotate("text", x = retorno_sharpe_mercado, y = 0.5, label = "Sharpe Máximo", color = "black", size = 4, angle = 90, vjust = 1) +
        geom_vline(xintercept = retorno_min_riesgo_mercado, color = "blue", linetype = "solid", size = 1) +
        annotate("text", x = retorno_min_riesgo_mercado, y = 0.5, label = "Mínimo Riesgo", color = "black", size = 4, angle = 90, vjust = 1) +
        scale_fill_manual(values = brewer.pal(n = length(unique(composicion_mercado_larga$Activo)), name = "Set3")) +
        labs(title = "Composition Map: Distribución de Pesos (Mercado)", x = "Retorno Esperado", y = "Peso en el Portafolio", fill = "Activo") +
        theme_minimal() +
        theme(legend.position = "right", legend.title = element_text(face = "bold"), legend.text = element_text(size = 10), plot.title = element_text(hjust = 0.5, face = "bold"))
    })
    
    composicion_bl <- data.frame(Retorno = resultado_bl$frontera$Retorno,
                             t(resultado_bl$pesos))

    composicion_bl_larga <- pivot_longer(composicion_bl,
                                     cols = -Retorno,
                                     names_to = "Activo",
                                     values_to = "Peso")
    
    message("Gráfico de composición de portafolios ", paste(head(composicion_bl), collapse = "\n"))
    
    output$composition_map_bl <- renderPlot({
      ggplot(composicion_bl_larga, aes(x = Retorno, y = Peso, fill = Activo)) +
        geom_area(position = "stack") +
        geom_vline(xintercept = retorno_sharpe_bl, color = "black", linetype = "solid", size = 1) +
        annotate("text", x = retorno_sharpe_bl, y = 0.5, label = "Sharpe Máximo", color = "black", size = 4, angle = 90, vjust = 1) +
        geom_vline(xintercept = retorno_min_riesgo_bl, color = "blue", linetype = "dashed", size = 1) +
        annotate("text", x = retorno_min_riesgo_bl, y = 0.5, label = "Mínimo Riesgo", color = "blue", size = 4, angle = 90, vjust = 1) +
        scale_fill_manual(values = brewer.pal(n = length(unique(composicion_mercado_larga$Activo)), name = "Set3")) +
        labs(title = "Composition Map: Distribución de Pesos (Black-Litterman)", x = "Retorno Esperado", y = "Peso en el Portafolio", fill = "Activo") +
        theme_minimal() +
        theme(legend.position = "right", legend.title = element_text(face = "bold"), legend.text = element_text(size = 10), plot.title = element_text(hjust = 0.5, face = "bold"))
    })
    
    message("Composition map generado.")
    
    
    pesos_minrisk_mercado <- resultado_mercado$pesos[, which.min(resultado_mercado$frontera[,2])]
    pesos_optimos_mercado <- resultado_mercado$pesos[, which.max(sharpe_ratios_mercado)]
    pesos_minrisk_bl <- resultado_bl$pesos[, which.min(resultado_bl$frontera[,2])]
    pesos_optimos_bl <- resultado_bl$pesos[, which.max(sharpe_ratios_bl)]
    
    pesos_optimos_mercado <- setNames(pesos_optimos_mercado, colnames(rent_diarios))
    pesos_minrisk_mercado <- setNames(pesos_minrisk_mercado, colnames(rent_diarios))
    pesos_optimos_bl <- setNames(pesos_optimos_bl, colnames(rent_diarios))
    pesos_minrisk_bl <- setNames(pesos_minrisk_bl, colnames(rent_diarios))
    
    message("Tabla pesos minimo riesgo mercado: ", paste(pesos_minrisk_mercado, collapse = ", "))
    message("Tabla pesos máximo Sharpe mercado: ", paste(pesos_minrisk_bl, collapse = ", "))
    message("Tabla pesos minimo riesgo BL: ", paste(pesos_minrisk_bl, collapse = ", "))
    message("Tabla pesos máximo Sharpe BL: ", paste(pesos_optimos_bl, collapse = ", "))
    
    message("Generando tablas de pesos")
    
    message("Generando violinplot")
    
    # Función para calcular IHH
    calcular_ihh <- function(pesos) {
      apply(pesos, 2, function(col) sum((col / sum(col))^2))
    }
    
    # Verificar que `pesos_mercado` y `pesos_bl` están bien definidos
    if (!exists("pesos_mercado") || !exists("pesos_bl")) {
      stop("Error: `pesos_mercado` o `pesos_bl` no están definidos correctamente.")
    }
    
    # Calcular IHH
    ihh_mercado <- calcular_ihh(pesos_mercado)
    message("IHH mercado", paste(head(ihh_mercado), collapse = "\n"))
            
    ihh_bl <- calcular_ihh(pesos_bl)
    message("IHH BL", paste(head(ihh_bl), collapse = "\n"))
    
    message("Longitud ihh_mercado: ", length(ihh_mercado))
    message("Longitud ihh_bl: ", length(ihh_bl))
    
    # Crear DataFrame solo con valores válidos
    df_ihh <- data.frame(
      Modelo = rep(c("Mercado", "Black-Litterman"), c(length(ihh_mercado), length(ihh_bl))),
      IHH = c(ihh_mercado, ihh_bl))
    
    message("data frame IHH", paste(head(df_ihh), collapse = "\n"))
    
    # Verificar si df_ihh tiene datos antes de graficar
    if (nrow(df_ihh) == 0) {
      stop("Error: No hay datos válidos para graficar IHH.")
    }
    
    output$grafico_violinplot <- renderPlot({
      ggplot(df_ihh, aes(x = Modelo, y = IHH, fill = Modelo)) +
        geom_violin(color = "darkblue", alpha = 0.7) +
        geom_boxplot(width = 0.1, color = "black", alpha = 0.5, outlier.shape = NA) +
        stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +
        labs(
          title = "Distribución del Índice de Herfindahl-Hirschman (IHH)",
          x = "Modelo",
          y = "IHH"
        ) +
        scale_y_continuous(limits = c(0, 1)) +
        theme_minimal() +
        theme(
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 14),
          plot.title = element_text(size = 18, hjust = 0.5),
          legend.position = "none"
        )
    })
    
    
    message("Violinplot generado")
    
    # Filtrar rentabilidad y calcular riesgo para los puntos que superan el mínimo riesgo

      ihh_mercado <- calcular_ihh(pesos_mercado[, which.min(resultado_mercado$frontera$Riesgo):ncol(pesos_mercado)])
      ihh_bl <- calcular_ihh(pesos_bl[, which.min(resultado_bl$frontera$Riesgo):ncol(pesos_bl)])
      
      message("IHH calculado")
      
      # Asegurar que Riesgo y Retorno sean consistentes con el IHH
      riesgo_mercado <- resultado_mercado$frontera$Riesgo[which.min(resultado_mercado$frontera$Riesgo):nrow(resultado_mercado$frontera)]
      riesgo_bl <- resultado_bl$frontera$Riesgo[which.min(resultado_bl$frontera$Riesgo):nrow(resultado_bl$frontera)]
      
      retorno_mercado <- resultado_mercado$frontera$Retorno[which.min(resultado_mercado$frontera$Riesgo):nrow(resultado_mercado$frontera)]
      retorno_bl <- resultado_bl$frontera$Retorno[which.min(resultado_bl$frontera$Riesgo):nrow(resultado_bl$frontera)]
      
      # Puntos de máximo Sharpe
      max_sharpe_mercado <- data.frame(
        IHH = ihh_mercado[which.max(sharpe_ratios_mercado)],
        Riesgo = riesgo_mercado[which.max(sharpe_ratios_mercado)],
        Rentabilidad = retorno_mercado[which.max(sharpe_ratios_mercado)],
        Modelo = "Mercado"
      )
      
      max_sharpe_bl <- data.frame(
        IHH = ihh_bl[which.max(sharpe_ratios_bl)],
        Riesgo = riesgo_bl[which.max(sharpe_ratios_bl)],
        Rentabilidad = retorno_bl[which.max(sharpe_ratios_bl)],
        Modelo = "Black-Litterman"
      )
      
      message("Max sharpe calculado")
      
      # Consolidar datos para el gráfico
      df_3d <- data.frame(
        IHH = c(ihh_mercado, ihh_bl),
        Riesgo = c(riesgo_mercado, riesgo_bl),
        Rentabilidad = c(retorno_mercado, retorno_bl),
        Modelo = rep(c("Mercado", "Black-Litterman"), times = c(length(ihh_mercado), length(ihh_bl)))
      )
      
      message("Primeras filas de df_3d", paste(head(df_3d), collapse = "\n"))
      
      # Crear gráfico interactivo con los puntos de máximo Sharpe
      output$grafico_3d <- renderPlotly({
      plot_ly(
        data = df_3d,
        x = ~IHH,
        y = ~Riesgo,
        z = ~Rentabilidad,
        color = ~Modelo,
        type = "scatter3d",
        mode = "markers",
        marker = list(size = 5, opacity = 0.7)
      ) %>%
        # Añadir puntos de máximo Sharpe
        add_trace(
          data = max_sharpe_mercado,
          x = ~IHH, y = ~Riesgo, z = ~Rentabilidad,
          type = "scatter3d",
          mode = "markers",
          marker = list(size = 10, color = "darkblue", symbol = "circle"),
          name = "Sharpe Máximo Mercado"
        ) %>%
        add_trace(
          data = max_sharpe_bl,
          x = ~IHH, y = ~Riesgo, z = ~Rentabilidad,
          type = "scatter3d",
          mode = "markers",
          marker = list(size = 10, color = "darkgreen", symbol = "circle"),
          name = "Sharpe Máximo Black-Litterman"
        ) %>%
        layout(
          title = "Gráfico 3D: Rentabilidad, Riesgo e IHH (con Máximo Sharpe)",
          scene = list(
            xaxis = list(title = "IHH"),
            yaxis = list(title = "Riesgo"),
            zaxis = list(title = "Rentabilidad")
          ),
          legend = list(orientation = "h", x = 0.3, y = -0.1)
        )
    })
    
    
    message("Grafico 3d generado")
    
    observeEvent(input$run_analysis, {
      pesos_minrisk_mercado <- tryCatch(pesos_minrisk_mercado, error = function(e) numeric(0))
      pesos_optimos_mercado <- tryCatch(pesos_optimos_mercado, error = function(e) numeric(0))
      pesos_minrisk_bl <- tryCatch(pesos_minrisk_bl, error = function(e) numeric(0))
      pesos_optimos_bl <- tryCatch(pesos_optimos_bl, error = function(e) numeric(0))
      
      # Generar tabla para cada conjunto de pesos
      output$tabla_minrisk_mercado <- renderUI({
        if (length(pesos_minrisk_mercado) == 0) {
          return(HTML("<p style='color: red;'>No se pudieron calcular los pesos para Mínimo Riesgo Mercado.</p>"))
        }
        tabla_html <- data.frame(`Peso Mínimo Riesgo Mercado (%)` = round(pesos_minrisk_mercado * 100, 2)) %>%
          knitr::kable("html", align = "c", caption = "Pesos Mínimo Riesgo Mercado") %>%
          kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))
        HTML(tabla_html)
      })
      
      output$tabla_optimos_mercado <- renderUI({
        if (length(pesos_optimos_mercado) == 0) {
          return(HTML("<p style='color: red;'>No se pudieron calcular los pesos para Sharpe Máximo Mercado.</p>"))
        }
        tabla_html <- data.frame(`Peso Sharpe Máximo Mercado (%)` = round(pesos_optimos_mercado * 100, 2)) %>%
          knitr::kable("html", align = "c", caption = "Pesos Sharpe Máximo Mercado") %>%
          kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))
        HTML(tabla_html)
      })
      
      output$tabla_minrisk_bl <- renderUI({
        if (length(pesos_minrisk_bl) == 0) {
          return(HTML("<p style='color: red;'>No se pudieron calcular los pesos para Mínimo Riesgo Black-Litterman.</p>"))
        }
        tabla_html <- data.frame(`Peso Mínimo Riesgo BL (%)` = round(pesos_minrisk_bl * 100, 2)) %>%
          knitr::kable("html", align = "c", caption = "Pesos Mínimo Riesgo Black-Litterman") %>%
          kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))
        HTML(tabla_html)
      })
      
      output$tabla_optimos_bl <- renderUI({
        if (length(pesos_optimos_bl) == 0) {
          return(HTML("<p style='color: red;'>No se pudieron calcular los pesos para Sharpe Máximo Black-Litterman.</p>"))
        }
        tabla_html <- data.frame(`Peso Sharpe Máximo BL (%)` = round(pesos_optimos_bl * 100, 2)) %>%
          knitr::kable("html", align = "c", caption = "Pesos Sharpe Máximo Black-Litterman") %>%
          kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))
        HTML(tabla_html)
      })
    })
    
    
    message("Pesos carteras generados")
    
    output$tabla_pesos_combinada <- renderUI({
      # Verificar y ajustar tamaños de los pesos
      pesos_minrisk_mercado <- tryCatch(pesos_minrisk_mercado, error = function(e) numeric(0))
      pesos_optimos_mercado <- tryCatch(pesos_optimos_mercado, error = function(e) numeric(0))
      pesos_minrisk_bl <- tryCatch(pesos_minrisk_bl, error = function(e) numeric(0))
      pesos_optimos_bl <- tryCatch(pesos_optimos_bl, error = function(e) numeric(0))
      
      activos <- tryCatch(colnames(rent_diarios), error = function(e) character(0))
      
      # Verificar que todos los vectores tengan el mismo tamaño que los activos
      n_activos <- length(activos)
      if (n_activos == 0 || any(c(length(pesos_minrisk_mercado), length(pesos_optimos_mercado),
                                  length(pesos_minrisk_bl), length(pesos_optimos_bl)) != n_activos)) {
        return(HTML("<p style='color: red;'>Los tamaños de los pesos no coinciden con el número de activos.</p>"))
      }
      
      # Crear tabla combinada
      data_combinada <- data.frame(
        Activo = activos,
        "Mínimo Riesgo Mercado (%)" = round(pesos_minrisk_mercado * 100, 2),
        "Peso Sharpe Máximo Mercado (%)" = round(pesos_optimos_mercado * 100, 2),
        "Peso Mínimo Riesgo BL (%)" = round(pesos_minrisk_bl * 100, 2),
        "Peso Sharpe Máximo BL (%)" = round(pesos_optimos_bl * 100, 2)
      )
      
      # Generar tabla HTML con kable
      tabla_html <- data_combinada %>%
        knitr::kable("html", align = "c", caption = "Pesos Combinados de las Carteras") %>%
        kableExtra::kable_styling(
          full_width = FALSE,
          bootstrap_options = c("striped", "hover", "condensed", "responsive")
        )
      
      # Renderizar tabla
      HTML(tabla_html)
    })
    
    
    message("Tabla pesos generada")
    
    message("Recuperando activos")
    activos <- colnames(rent_diarios)
    
    if (is.null(activos) || length(activos) == 0) {
      stop("Error: La lista de activos está vacía antes de llamar a getSymbols().")
    }
    
    message("Fechas de evaluacion")
    
    start_date <- input$evaluation_start_date
    end_date <- input$evaluation_end_date
    
    message("Fechas de evaluacion", paste(input$evaluation_start_date, collapse = ", "))
    message(paste(input$evaluation_start_date, collapse = ", "))
    message(input$evaluation_end_date, collapse = ", ")
    
    message("Calculando cartera pesos optimos mercado")
    resultados_mercado <- analizar_rebalanceo(pesos_optimos_mercado, fecha_inicio = start_date, fecha_fin = end_date, inversion = 1000000, margen = 0.03, trading_cost = 0.01)
    resultados_mercado_no <- analizar_sin_rebalanceo(pesos_optimos_mercado, fecha_inicio = start_date, fecha_fin = end_date, inversion = 1000000)
    
    message("Calculando cartera pesos optimos BL")
    resultados_BL <- analizar_rebalanceo(pesos_optimos_bl, fecha_inicio = start_date, fecha_fin = end_date, inversion = 1000000, margen = 0.03, trading_cost = 0.01)
    resultados_BL_no <- analizar_sin_rebalanceo(pesos_optimos_bl, fecha_inicio = start_date, fecha_fin = end_date, inversion = 1000000)
    
    message("Resultados analisis completados")
    
    message("Creando grafico evolucion carteras")
    
    # Obtener datos del S&P 500 y calcular series normalizadas
    sp500_data <- getSymbols("^GSPC", from = start_date, to = end_date, src = "yahoo", auto.assign = FALSE)
    sp500 <- Cl(sp500_data)
    sp500_normalizado <- cumprod(1 + na.omit(dailyReturn(sp500, type = "log")))
    
    # Normalizar rentabilidades de mercado y Black-Litterman
    resultados_mercado <- lapply(resultados_mercado, function(x) x + 1)
    resultados_BL <- lapply(resultados_BL, function(x) x + 1)
    
    # Crear un dataframe consolidado para el gráfico
    data_grafico <- data.frame(
      Fecha = index(sp500_normalizado)[-1],
      Mercado_Bruta = resultados_mercado$Rentabilidad_Bruta,
      Mercado_Neta = resultados_mercado$Rentabilidad_Neta,
      BL_Bruta = resultados_BL$Rentabilidad_Bruta,
      BL_Neta = resultados_BL$Rentabilidad_Neta,
      Mercado_Sin_Rebalanceo = resultados_mercado_no$Rendimiento_Sin_Rebalanceo,
      BL_Sin_Rebalanceo = resultados_BL_no$Rendimiento_Sin_Rebalanceo,
      SP500 = as.numeric(sp500_normalizado)[-1]
    )
    
    # Crear gráfico
    output$grafico_rentabilidades <- renderPlot({
      ggplot(data_grafico, aes(x = Fecha)) +
        geom_line(aes(y = Mercado_Neta, color = "Mercado (Con Rebalanceo)"), size = 0.8) +
        geom_line(aes(y = Mercado_Sin_Rebalanceo, color = "Mercado (Sin Rebalanceo)"), size = 0.8, linetype = "dashed") +
        geom_line(aes(y = BL_Neta, color = "BL (Con Rebalanceo)"), size = 0.8) +
        geom_line(aes(y = BL_Sin_Rebalanceo, color = "BL (Sin Rebalanceo)"), size = 0.8, linetype = "dashed") +
        geom_line(aes(y = SP500, color = "S&P 500"), size = 1.5) +
        scale_color_manual(values = c(
          "Mercado (Con Rebalanceo)" = "#1f77b4", "Mercado (Sin Rebalanceo)" = "#aec7e8",
          "BL (Con Rebalanceo)" = "#d62728", "BL (Sin Rebalanceo)" = "#ff9896", "S&P 500" = "black"
        )) +
        labs(
          title = "Comparación de Rentabilidades Netas",
          x = "Fecha", y = "Rentabilidad Normalizada", color = "Estrategia"
        ) +
        theme_minimal() +
        theme(
          legend.position = "bottom", legend.title = element_text(face = "bold"),
          legend.text = element_text(size = 10), plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
          axis.text.x = element_text(angle = 45, hjust = 1)
        )
    })
    
    message("Grafico evolucion carteras completado")
    
    output$tabla_comparativa <- renderUI({
      rentabilidad_total <- round(sapply(data_grafico[, -1], function(serie) {
        (last(na.omit(serie)) - 1) * 100
      }), 2)
      
      volatilidad <- round(sapply(data_grafico[, -1], function(serie) {
        returns <- diff(log(na.omit(serie)))
        sd(returns, na.rm = TRUE) * sqrt(252) * 100
      }), 4)
      
      downside_risk <- sapply(data_grafico[, -1], function(serie) {
        returns <- diff(log(na.omit(serie)))
        DownsideDeviation(returns, MAR = 0) * sqrt(252) * 100
      })
      
      max_drawdown <- sapply(data_grafico[, -1], function(serie) {
        serie <- na.omit(serie)
        drawdowns <- cummax(serie) - serie
        max(drawdowns) / cummax(serie)[which.max(drawdowns)] * 100
      })
      
      mean_drawdown <- sapply(data_grafico[, -1], function(serie) {
        serie <- na.omit(serie)
        drawdowns <- cummax(serie) - serie
        mean(drawdowns / cummax(serie)) * 100
      })
      
      sp500_returns <- diff(log(na.omit(data_grafico$SP500)))
      
      alpha_beta <- sapply(data_grafico[, -1], function(serie) {
        # Calcular rentabilidades logarítmicas diarias de la serie
        serie_returns <- diff(log(na.omit(serie)))
        
        # Calcular beta utilizando la fórmula Cov/Var
        beta <- cov(serie_returns, sp500_returns, use = "complete.obs") / var(sp500_returns, na.rm = TRUE)
        
        periodo <- as.numeric(difftime(as.Date(end_date), as.Date(start_date), units = "days")) / 365
        Rf_ajustado <- Rf_anual^periodo
        
        # Calcular Alpha
        rendimiento_portafolio <- last(na.omit(serie)) - 1  # Rentabilidad total del portafolio
        rendimiento_mercado <- last(na.omit(data_grafico$SP500)) - 1  # Rentabilidad total del mercado
        alpha <- (rendimiento_portafolio - (Rf_ajustado + beta * (rendimiento_mercado - Rf_ajustado))) * 100
        
        return(c(Alpha = alpha, Beta = beta))
      })
      
      # Convertir alpha_beta en un data.frame
      alpha_beta_df <- as.data.frame(t(alpha_beta))
      colnames(alpha_beta_df) <- c("Alpha", "Beta")
      
      # Asignar Alpha y Beta para el S&P 500
      alpha_beta_df["SP500", ] <- c(Alpha = 0, Beta = NA)
      
      # Crear tabla comparativa
      tabla_comparativa <- data.frame(
        Rentabilidad_Total = rentabilidad_total,
        Volatilidad = volatilidad,
        Downside_Risk = downside_risk,
        Max_Drawdown = round(max_drawdown, 2),
        Mean_Drawdown = round(mean_drawdown, 2),
        Alpha = round(alpha_beta_df$Alpha, 2),
        Beta = round(alpha_beta_df$Beta, 2)
      )
      
      # Generar tabla HTML estilizada con kable
      tabla_html <- tabla_comparativa %>%
        knitr::kable("html", align = "c", caption = "Comparativa de Métricas de Rendimiento") %>%
        kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))
      
      HTML(tabla_html)
    })
  })
}

shinyApp(ui = ui, server = server)
